Подключение к сетевому оборудованию через терминальный сервер. Для подключения использовался SecureCRT. Терминальный сервер x.x.x.x. 

```python
import json  
import time  
from netmiko import ConnectHandler  
  
# Конфигурация для подключения к терминальному серверу (jump host)  
jump_host = {  
    'device_type': 'terminal_server',  
    'host': 'x.x.x.x',  
    'username': 'логин',  
    'password': 'пароль',  
    'port': 22,  
    'session_log': 'session.log'  
}  
  
# Чтение конфигурации целевых устройств из JSON-файла  
with open('devices_config.json', 'r') as f:  
    devices_config = json.load(f)  
  
try:  
    # Подключение к терминальному серверу (jump host)  
    print("Подключение к терминальному серверу...")  
    net_connect = ConnectHandler(**jump_host)  
    print(f"Приглашение терминального сервера: {net_connect.find_prompt()}")  
  
    # Перебираем список целевых устройств  
    for device in devices_config:  
        try:  
            # Пересылка на новое устройство через SSH  
            print(f"\nПересылка на устройство {device['host']}")  
            net_connect.write_channel(f"ssh {device['username']}@{device['host']}\n")  
            time.sleep(3)  
  
            # Проверка запроса на ввод пароля  
            output = net_connect.read_channel()  
            if 'Password:' in output:  
                net_connect.write_channel(f"{device['password']}\n")  
                time.sleep(3)  
  
            # Перенастройка Netmiko на новый тип устройства  
            net_connect.redispatch(device_type=device['device_type'])  
  
            # Проверка, что мы успешно подключились к целевому устройству  
            if not net_connect.check_enable_mode():  
                print("Ошибка: Не удалось переключиться в режим enable.")  
                continue  
  
            print("Название оборудования: {}".format(net_connect.find_prompt()))  
  
            # Отправка команды и получение вывода с использованием TextFSM  
            print("Выполнение команды...")  
            new_output = net_connect.send_command("sh ip int brief", use_textfsm=True)  
            print(new_output)  
  
            # Сохранение вывода в JSON-файл  
            filename = f"output_{device['host']}.json"  
            with open(filename, 'w', encoding='utf-8') as f:  
                json.dump(new_output, f, indent=4, ensure_ascii=False)  
            print(f"Вывод сохранен в файл {filename}")  
        except Exception as e:  
            print(f"Ошибка при работе с устройством {device['host']}: {e}")  
  
        finally:  
            # Возврат на терминальный сервер  
            net_connect.write_channel("logout\n")  
            time.sleep(3)  
  
except Exception as e:  
  
    print(f"Произошла ошибка: {e}")  
  
finally:  
  
    # Закрытие сессии  
    if 'net_connect' in locals():  
        net_connect.disconnect()
```

File= devices_config.json for sript
```json
[
    {
        "device_type": "cisco_ios",
        "host": "x.x.x.x",
        "username": "логин",
        "password": "пароль",
        "session_log": "session_1.log"
    },
    {
        "device_type": "cisco_ios",
        "host": "x.x.x.x",
        "username": "логин",
        "password": "пароль",
        "session_log": "session_2.log"
    },
    {
        "device_type": "cisco_ios",
        "host": "x.x.x.x",
        "username": "логин",
        "password": "пароль",
        "session_log": "session_3.log"
    }
]
```
Также использовались статьи [Автоматизация сетевого оборудования на Python. Работа через jump-host / Хабр](https://habr.com/ru/companies/rostelecom/articles/823282/)

________________________________________________________________________
Paths: [[Scripts]]
Tags: #Scripts   

